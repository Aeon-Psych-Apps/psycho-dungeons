name: Build latest.json & Update Changelog

on:
  push:
    branches: [ "test" ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: test

      - name: Ensure correct branch
        run: |
          if [ "$(git rev-parse --abbrev-ref HEAD)" != "test" ]; then
            echo "Not on test branch. Exiting."
            exit 0
          fi

      - name: Find last merge of test into main
        id: lastmerge
        run: |
          LAST=$(git log main..test --merges --pretty=format:"%H" | head -n 1)
          if [ -z "$LAST" ]; then
            LAST=$(git rev-list --max-parents=0 test)
          fi
          echo "last_merge=$LAST" >> $GITHUB_OUTPUT

      - name: Generate commit entries since last merge
        id: commits
        run: |
          START=${{ steps.lastmerge.outputs.last_merge }}
          LOG=$(git log ${START}^..HEAD --no-merges --pretty=format:"%s%x09%b" | awk '
            BEGIN { RS="\n"; FS="\t"; ORS=""; features=""; fixes=""; patches=""; misc=""; }
            {
              subject=$1; body="";
              if(NF>1){ for(i=2;i<=NF;i++){ if($i!="") body=body"    - "$i"\n"; } }

              lc_subject=tolower(subject)
              if(lc_subject ~ /^internal:/) next
              if(lc_subject ~ /^update changelog/ || lc_subject ~ /\[skip ci\]/) next

              key = subject body
              if(seen[key]++) next

              entry="- " subject "\n" body

              if(lc_subject ~ /^feature:/){
                sub(/^feature:[ ]*/i,"",entry); features=features entry "\n"
              } else if(lc_subject ~ /^fix:/){
                sub(/^fix:[ ]*/i,"",entry); fixes=fixes entry "\n"
              } else if(lc_subject ~ /^patch:/){
                sub(/^patch:[ ]*/i,"",entry); patches=patches entry "\n"
              } else {
                misc=misc entry "\n"
              }
            }
            END {
              if(features!="") print "### Features\n" features "\n"
              if(fixes!="") print "### Fixes\n" fixes "\n"
              if(patches!="") print "### Patches\n" patches "\n"
              if(misc!="") print "### Misc\n" misc "\n"
            }
          ')
          echo "log<<EOF" >> $GITHUB_OUTPUT
          echo "$LOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Prepend entries to CHANGELOG.md
        run: |
          # Read version from config.json
          VERSION=$(python3 -c "import json; print(json.load(open('config/config.json'))['github_version'])")
          
          DATE="$(TZ=America/Phoenix date +"%m/%d/%Y %H:%M %Z")"
          mkdir -p manual
          if [ ! -f manual/patch_notes.md ]; then
            echo "# Patch Notes" > manual/patch_notes.md
          fi

          # Prepend categorized commits to CHANGELOG.md
          {
            echo "$VERSION - [$DATE]"
            echo ""
            echo "${{ steps.commits.outputs.log }}"
          } > CHANGELOG.tmp

          # Append existing patch_notes
          echo "" >> CHANGELOG.tmp
          echo "---" >> CHANGELOG.tmp
          cat manual/patch_notes.md >> CHANGELOG.tmp
          echo "" >> CHANGELOG.tmp
          mv CHANGELOG.tmp CHANGELOG.md

      - name: Build latest.json
        run: |
          python3 <<'EOF'
          import os, json, base64, mimetypes

          def read_text(path):
              with open(path, "r", encoding="utf-8") as f:
                  return f.read()

          def read_files(dir_path, exts=None):
              files_data = []
              for file in os.listdir(dir_path):
                  if exts and not any(file.endswith(e) for e in exts):
                      continue
                  path = os.path.join(dir_path, file)
                  if os.path.isdir(path):
                      continue
                  with open(path, "rb") as f:
                      b64 = base64.b64encode(f.read()).decode("utf-8")
                  mime_type, _ = mimetypes.guess_type(path)
                  if not mime_type:
                      mime_type = "application/octet-stream"
                  files_data.append({"name": file, "type": mime_type, "contents": b64, "display_logo": True})
              return files_data

          with open("config/config.json", "r", encoding="utf-8") as f:
              config = json.load(f)

          scripts = [{"name": os.path.splitext(f)[0], "contents": read_text(os.path.join("scripts", f))}
                     for f in os.listdir("scripts") if f.endswith(".py")]

          manual = [{"name": os.path.splitext(f)[0], "contents": read_text(os.path.join("manual", f))}
                    for f in os.listdir("manual") if f.endswith(".md")]

          images = read_files("images")

          change_log = {"contents": read_text("CHANGELOG.md")}

          latest = {
              "config": config,
              "scripts": scripts,
              "images": images,
              "manual": manual,
              "change_log": change_log
          }

          with open("latest.json", "w", encoding="utf-8") as f:
              json.dump(latest, f, indent=2)
          EOF

      - name: Commit and push
        run: |
          set -e
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add CHANGELOG.md manual/patch_notes.md latest.json

          if ! git diff --cached --quiet; then
            git commit -m "Update CHANGELOG & patch_notes for $DATE [skip ci]"
            git push
          else
            echo "No changes to commit"
          fi
